## 原型模式（Proto Type)

- 详情见代码

#### 思路：
- Java中Object类是所有类的根类（基类），Object类提供了一个clone方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 => 原型模式

#### 为什么用：
- 在我们应用程序中可能有某些对象的结构比较复杂，但是我们有需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
- 它主要应用于哪些创建新对象的成本过大时。
- 它的主要有优点是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构。

#### 模式结构：
- 原型模式包含如下角色：
    - ProtoTyep：抽象原型类，声明一个克隆自己的接口
    - ConcreteProtoType：具体原型类，实现一个克隆自己的操作
    - Client：客户类，让一个原型对象克隆自己，从而创建一个新的对象（属性一样）
    
#### 简介：
- 原型模式虽然是创建型的模式，但是与工程模式没有关系
- 从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象
- Java中，复制对象是通过clone()实现的。

#### 大致实现思想：
- 一个原型类，只需要实现Cloneable接口
- 覆写clone方法，此处clone方法可以改成任意的名称
- 因为Cloneable接口是个空接口，你可以任意定义实现类的方法名
- 此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法
- 而在Object类中，clone()是native的，具体实现此处不予赘述

#### 原型思想-拷贝（浅拷贝、深拷贝）

##### 浅拷贝：
- 将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的

##### 深拷贝：
- 将一个对象复制后，不论是基本数据类型还是引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底
- 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象

##### 深拷贝实现方式
- 方式1：重写clone方法来实现深拷贝
- 方式2：通过对象序列化来实现深拷贝

#### 原型模式在Spring框架中
- Spring中原型bean的创建，就是原型模式的应用
- 代码分析
```
beans.xml
<!-- 这里的 scope="prototype" ，即 原型模式来创建 -->
<bean id = "xxx" class="com.sean.spring.bean.xxx" scope="prototype" />

Test.java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
// 获取xxx【通过id获取xxx】
Object bean = applicationContext.getBean("xxx");
```

#### 原型模式的注意事项和细节
- 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
- 不用重新初始化对象，而是动态的获得对象运行时的状态
- 如果原始对象发生变化（增加或者减少属性），其它克隆对象也会发生相应的变化，无需修改代码
- 在实现深clone的时候可能需要比较复杂的代码
- 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则