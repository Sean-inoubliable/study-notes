- SourceVideo https://www.bilibili.com/video/av57936239
### 设计模式的目的
- 编写软件过程中，程序员面临着来自 ***耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性*** 等多方面的挑战，设计模式是为了让程序（软件）具有更好的以下特性：
    - 代码重用性
        - 即：相同功能的代码，不用多次编写
    - 可读性
        - 即：编程规范性，便于其他程序员的阅读和理解
    - 可扩展性
        - 即：当需要增加新的功能时，非常的方便，成本低。也称可维护性
    - 可靠性
        - 即：当增加新的功能后，对原有的功能没有影响
    - 使程序呈现高内聚，低耦合的特性
    
### 设计模式的分类
- 总体来说设计模式分为三大类(23种） + 另两类（2种）
    - 创建型模式，共五种：（对象实例化的模式，创建型模式用于解耦对象的实例化过程）
        - 单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式
    - 结构型模式，共七种：
        - 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
    - 行为型模式，共十一种：
        - 策略模式、模板方法模式、观察者模式、迭代子模式、责任连模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
    - 另两类：
        - 并发型模式、线程池模式
- 各模式的关键点：
    - 单例模式：某个类只能有一个实例，提供一个全局的访问点
    - 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例
    - 工厂方法：定义一个创建对象的接口，让子类决定实例化那个类
    - 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类
    - 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构建
    - 原型模式：通过复制现有的实例来创建新的实例
    - 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口
    - 装饰器模式：动态的给对象添加新的功能
    - 代理模式：为其他对象提供一个代理以便控制这个对象的访问
    - 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口
    - 桥接模式：将抽象部分和它的实现部分分离，是它们都可以独立的变化
    - 组合模式：将对象组合成树形结构以表示‘部分-整体’的层次结构
    - 享元模式：通过共享技术来有效的支持大量细粒度的对象
    - 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现
    - 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器
    - 策略模式：定义一系列算法，把他们封装起来，并且是它们可以相互替换
    - 状态模式：允许一个对象在其对象内部状态改变时改变它的行为
    - 观察者模式：对象间的一对多的依赖关系
    - 备忘录模式：在不破坏封装的前提下，保持对象的内部状态
    - 中介者模式：用一个中介对象来封装一系列的对象交互
    - 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化
    - 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能
    - 责任连模式：将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会
    - 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构
    
    
    

### 设计模式七大原则
1) 单一职责原则
2) 接口隔离原则
3) 依赖倒转原则
4) 里氏替换原则
5) 开闭原则
6) 迪米特法则
7) 合成复用原则

### 单一职责原则
- 对类来说，即一个类应该只负责一项职责

#### 单一职责原则注意事项和细节
- 降低类的复杂度，一个类只负责一项职责
- 提高类的可读性，可维护性
- 降低变更引起的风险
- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 接口隔离原则（Interface Segregation Principle）
- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

### 依赖倒转原则（Dependence Inversion Principle）
- 高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象
- 依赖倒转的中心思想是面向接口编程
- 在Java中，抽象指的是接口或抽象类，细节就是具体的实现类
- 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成
- 开闭原则的基础。真对接口编程，依赖于抽象而不依赖于具体。

#### 依赖倒转原则的注意事项和细节
- 底层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
- 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
- 继承时遵循里氏替换原则

### 里氏替换原则
- 所有引用基类的地方，必须能透明的使用其子类的对象
- 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法

### 开闭原则（Open Closed Principle）

#### 基本介绍
- 开闭原则是编程中最基础、最重要的设计原则
- 一个软件实体如类，模块和函数应该对扩展开发（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节
- 当软件需要变化时，尽量通过扩展软件实体的行为来进行实现变化，而不是通过修改已有的代码来实现变化
- 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则

### 迪米特法则（Demeter Principle)

#### 基本介绍
- 一个对象应该对其他对象保持最少的了解
- 类与类关系越密切，耦合度越大
- 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息
- 迪米特法则还有个更简单的定义：只与直接的朋友通信

#### 迪米特法则注意事项和细节
- 迪米特法则的核心是降低类之间的耦合
- 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间耦合关系，并不是要求完全没有依赖关系

### 合成复用原则（Composite Reuse Principle)

#### 基本介绍
- 原则是尽量使用合成/聚合的方式，而不是使用继承